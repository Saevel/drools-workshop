package prv.saevel.drools.workshop.antifraud;

import prv.saevel.drools.workshop.antifraud.FraudScore;
import prv.saevel.drools.workshop.antifraud.FraudEvent;
import prv.saevel.drools.workshop.antifraud.FraudEventType;
import prv.saevel.drools.workshop.antifraud.Country;
import prv.saevel.drools.workshop.model.Account;
import prv.saevel.drools.workshop.model.Transaction;
import prv.saevel.drools.workshop.model.TransactionType;
import prv.saevel.drools.workshop.model.User;

global prv.saevel.drools.workshop.antifraud.AccountService accountService;

rule "Create fraud score if absent"
    when
        Account($accountId : id, $userId : userId, $balance: balance, c1 : currency)
        not FraudScore(accountId == $accountId, s : score)
    then
        insert(new FraudScore($accountId, 0.0));
    end

rule "Transaction from a blacklisted country"
    when
        Account($accountId : id, $userId : userId, b : balance, c1 : currency)
        Transaction(i : id, accountId == $accountId, t : timestamp, $country : country, a : amount, c2 : currency)
        Country(name == $country, blacklisted == true)
    then
        insert(new FraudEvent($accountId, FraudEventType.TRANSACTION_FROM_BLACKLISTED_COUNTRY, false));
    end

rule "Account emptying transaction"
    when
        Account($accountId : id, $userId : userId, $balance: balance, c1 : currency)
        Transaction(i : id, accountId == $accountId, t: timestamp, $country : country, amount >= (0.9 * $balance), c2 : currency)
    then
        insert(new FraudEvent($accountId, FraudEventType.ACCOUNT_EMPTYING, false));
    end

rule "Transactions from multiple countries in short succession"
    when
        Transaction(i1 : id, $accountId : accountId, t1: timestamp, $country : country, a1 : amount, c1 : currency)
        Transaction(i2 : id, accountId == $accountId, t2: timestamp , country != $country, a2: amount, c2 : currency)
    then
        if(t1 - t2 < 180 && t1 - t2 > -180){
            insert(new FraudEvent($accountId, FraudEventType.TRANSACTION_FROM_MULTIPLE_COUNTRIES, false));
        }
    end

rule "Update fraud score for blacklisted countries"
    when
        $fraudScore : FraudScore($accountId : accountId, $score : score)
        $event : FraudEvent(accountId == $accountId, type == FraudEventType.TRANSACTION_FROM_BLACKLISTED_COUNTRY, processed == false)
    then
        $event.setProcessed(true);
        update($event);
        $fraudScore.setScore($score + 0.5);
        update($fraudScore);
    end

rule "Update fraud score for transactions from multiple countries"
    when
        $event : FraudEvent($accountId : accountId, type == FraudEventType.TRANSACTION_FROM_MULTIPLE_COUNTRIES, processed == false)
        $fraudScore : FraudScore(accountId == $accountId, $score : score)
    then
        $event.setProcessed(true);
        update($event);
        $fraudScore.setScore($score + 1.0);
        update($fraudScore);
    end

rule "Update fraud score for account emptying"
    when
        $event : FraudEvent($accountId : accountId, type == FraudEventType.ACCOUNT_EMPTYING, processed == false)
        $fraudScore : FraudScore(accountId == $accountId, $score : score)
    then
        $event.setProcessed(true);
        update($event);
        $fraudScore.setScore($score + 1.0);
        update($fraudScore);
    end

rule "Block non-trusted user"
    when
        Account($accountId : id, $userId : userId, $balance: balance, c1 : currency)
        FraudScore(accountId == $accountId, score >= 2.0)
        User(id == $userId, c2 : country, acc : accounts, trusted == false)
    then
        accountService.blockAccount($accountId);
    end

rule "Block trusted user"
    when
        Account($accountId : id, $userId : userId, $balance: balance, c1 : currency)
        FraudScore(accountId == $accountId, score >= 3.0)
    then
        accountService.blockAccount($accountId);
    end

query findFraudEvent(long id, FraudEventType eventType)
    $event : FraudEvent(accountId == id, type == eventType)
end